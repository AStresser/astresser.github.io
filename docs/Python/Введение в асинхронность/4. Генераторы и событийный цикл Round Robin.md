
# 4. Генераторы и событийный цикл Round Robin

## Почему генераторы - в первую очередь функции, а не спископодобные объекты?

Потому что их главная особенность - это не способ возврата значений, а передача контроля выполнения при помощи ключевого слова `yield`.

## В чем заключается принцип работы генератора?

**Генератор** - это функция, способная вместе с последовательными значениями на время возвращать контроль выполнения в основную программу и получать его обратно после выполнения специальной функции `next()`. В случае, если генератор был вызван через `next()`, а возвращаемых значений не осталось - он возбуждает исключение `StopIteration`.

## Главные отличия yield от return?

- `return` возвращает контроль выполнения окончательно и новый вызов функции будет выполняться с начала.
- `yield` возвращает контроль выполнения на время и следующий вызов функции через `next()` будет выполняться от `yield` до `yield`.

## Какими двумя практическими моментами ключевое слово yield отличается от return?

- `yield` позволяет помещать код после себя - он выполнится при следующем вызове `next()`, то есть `yield` разбивает тело функции, а не завершает их как `return`.
- в отличие от `return`, мы можем разместить более одного `yield` друг за другом и таким образом разделить тело функции на сегменты, которые будут выполняться после соответствующего вызова `next()`.

## Опишите принцип работы Round Robin

Rond Robin можно представить в виде очереди, где первый выполняет определенную работу, после чего уходит в конец и снова ожидает наступления своей очереди, а второй становится первым и также выполняет работу, после чего уходит в конец.

## Как будет выглядеть Round Robin из двух генераторов?

```python
# 1. Создаем очередь tasks в виде списка
# 2. Запускаем цикл, который будет работать пока очередь не пустая, то есть
# пока у генераторов не кончатся значения
# 3. В цикле while True извлекаем первый элемент очереди и передаем ему контроль для выполнения своей задачи, а потом возвращаем в конец списка. Если задачи (возвращаемые значения) кончились - пропускаем и вынимаем следующий за ним элемент.
tasks = [g1, g2]
while True:
	task = tasks.pop(0)
	try:
		next(task)
		tasks.append(task)
	except StopIteration:
		pass

```